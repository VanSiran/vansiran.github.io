---
layout: default
title: B指令引发的思考／初识连接器
---
<h2>B指令引发的思考／初识连接器</h2>

<p>在ARM汇编中，使用 B 、BL 指令进行跳转时，我们可能会使用两种方式：</p>

<ol>
	<li>跳转到标号</li>
	<li>跳转到某个绝对地址</li>
</ol>

<p>那么，B指令在跳转时，究竟是如何对目标地址进行寻址的？</p>

<p>查阅ARM指令文档：</p>

<blockquote>
<p> ASSEMBLER SYNTAX：</p>

<p>B{L}{Cond} &lt;expression&gt;</p>

<p>&lt;expression&gt;：The destination. The assembler calculates the offset </p>
</blockquote>

<p>指令格式如下：</p>

<figure><img src="%E6%9C%AA%E5%91%BD%E5%90%8D.tiff"/></figure>

<p>可以看到[0:23]代表偏移量，而偏移量以指令为单位，能够相对寻址±8M的指令条数，寻址空间达到± 32MB。这就是说，B指令采用相对寻址机制，偏移是由汇编器进行计算得出的。</p>

<p><strong>这里得到了一条基本共识：B指令采用相对寻址。</strong></p>

<h3>一项实验 </h3>

<p>下面进行一项实验来观察各类跳转。</p>

<pre><code>//假设这段裸机程序加载在0x00000000地址处
.global _start
.text
_start:
	b 0x8            //跳转到本程序内地址
	b 0x100        //跳转到本程序外地址
 	b loop           //跳转到标号loop处
	b 0x30000000    //超出B偏移范围
loop:
	b loop            //死循环
	b .                  //也是死循环，小点点 . 代表本条指令的绝对地址，来看看两种死循环有没有区别。
</code></pre>

<p>通过对上面六条跳转指令进行反汇编，我们观察一下汇编器到底是怎么处理他们的。使用 arm-none-eabi-as 汇编成ELF后，arm-none-eabi-objdump -d 查看反汇编。</p>

<figure><img src="VirtualBox_MOOC_29_09_2016_22_30_37.png"/></figure>

<p>结论：</p>

<ol>
	<li>跳转到标号的指令，会被汇编成具有明确跳转地址的机器码。例如：地址0x8处:<code>b loop</code>的汇编结果是0xEA000000，0xEA代表无条件跳转，0x000000是跳转偏移量，这条指令地址是0x8，PC超前8字节，即PC = 0x10，偏移0条指令后，地址正好是loop标号指向的0x10。</li>
	<li>跳转到绝对地址的指令，不管跳转到哪，一律汇编成了0xEAFFFFFE。指令偏移量是0xFFFFFE，即-2。由于PC超前2条指令，加上指令偏移量-2，结果是0，故0xEAFFFFFE是一条原地死循环。</li>
</ol>

<h3>一个问题</h3>

<p>所有的绝对地址跳转都变成死循环了吗，我们明确的写好了要跳转的地址，结果汇编器却不听话，玩起死循环了吗？</p>

<p>反思上述实验，在这里需要提到上面的一个误区：我们<strong>假定</strong>程序加载在内存0x00000000处——可这只是我们自己设的假定，汇编器可什么假设都没做。</p>

<p>让我们一错到底，看看会发生什么后果。</p>

<p>我们继续自作聪明的认为，汇编器同我们存在默契，它默认程序第一条语句处于内存0x00000000。如果真是这样，那它就十分清楚该怎么做了。拿第二条指令举个例子吧，由于程序第一条指令加载到0x00000000处，那么第二条指令<code>b 0x100</code> 将加载到的0x00000004处，它的目标是跳到0x100处。汇编器掐指一算，哦，当前PC = 0x4 + 0x8 = 0xC，与目标地址偏差0x100 - 0xC = 0xF4，换算成指令条数0xF4 / 4 = 0x3D，于是得出汇编结果：0xEA00003D。其他的绝对地址跳转都是这么算出来的（先不提<code>b 0x30000000</code>那句，后面详细讨论）。</p>

<p>我们不禁心生感慨，跟我们有默契的编译器，才是听话，好用的编译器嘛！这不是，按照上面的算法，跳转的地址不是都按照我们的意志好好的算出来了吗。</p>

<p>哪有那么好的事，现实中不存在猜透人心思的汇编器！汇编器是一个行事严谨的家伙，不会乱做假设，否则，吃苦的反而是程序员。</p>

<p>比如，如果程序没有加载到0x00000000呢？汇编器仍按照第一条指令地址为0x00000000处理，第二条指令仍汇编成了0xEA00003D。若程序被加载到了0x00000100处，现在第二条指令位于0x00000104，执行后跳转到了0x00000200处，根本就不是我们想去的0x00000100了。由此可见，对于包含绝对地址跳转的程序，加载地址必须在编译时就决定好，并把决定好的加载地址告诉编译器。只有这样，编译器才能一毫不差的给出最后的程序，得到的程序才能按部就班的执行。</p>

<p>汇编器并不知道加载地址，又不能妄下结论，怎么办？它把自己本职工作——汇编做好后，把自己无法确定的东西占个空位，让别人来完成。这个空位就是上面程序汇编后的产生的一堆死循环0xEAFFFFFE。留了空位，还要留一些线索给后人，那就是<strong>重定位表</strong>。</p>

<p>来看看重定位表吧。用objdump -r 检查重定位表，发现每一条绝对跳转指令都对应着一个重定位项，表项的内容对应了我们汇编代码中写下的绝对地址。</p>

<figure><img src="VirtualBox_MOOC_29_09_2016_22_48_29.png"/></figure>

<p>例如：OFFSET=0xC的指令对应的VALUE=0x30000000，对应我们上面实验程序的第四条指令，b 0x30000000。VALUE还用*ABS*表示这是个绝对地址。这些线索足以确定空位处到底该填写哪些具体偏移量了。</p>

<p>回顾实验，那些标号跳转指令与目标标号的距离在编译时就固定不动了，于是汇编器就能够给出具体的跳转机器码。另外需要注意的是，<code>b .</code>和<code>b loop</code>虽然汇编后的机器码也是0xEAFFFFFE，但它们可不是跳转的占位符，而是真正的死循环。上面我们提到，小点点 . 代表本条指令的地址，但是汇编器不会把它理解为绝对地址，因为它的相对偏移在编译时可以确定，本条指令就是本条指令，不管放到哪里相对偏移都是-0x8。这两种死循环方式都不利用重定位表，可见这两种循环方式的汇编过程是一模一样的。</p>

<h3>问题终结者</h3>

<p>我们将请来GNU工具链里另一名大将：连接器——LD，帮我们终结上述的问题。</p>

<p>我们会把加载地址，程序各个段的位置，都详细的告诉LD。LD会根据我们的需求，重新计算并填充重定位表里描述的那些空位们。</p>

<p>在linker.lds写入下面的连接器脚本：</p>

<pre><code>SECTIONS
{
    . = 0x00000000;
    .text : { *(.text) }
}
</code></pre>

<p>使用arm-none-eabi-ld -Tlinker.lds -o b.elf a.out 把汇编器的输出a.out加工成b.elf。</p>

<p>这段脚本告诉连接器最终输出程序的各个段的地址配置。熟悉的小点点还是代表当前地址，告诉连接器，当前地址是0x00000000，后面的<code>.text : { *(.text) }</code>告诉LD这里放所有参与连接的ELF文件的代码段。这不就是形象的告诉LD：“在0x00000000这里，放上我的程序的代码。”</p>

<p>再用 arm-none-eabi-objdump -d 查看LD的劳动果实吧：</p>

<figure><img src="VirtualBox_MOOC_30_09_2016_01_49_01.png"/></figure>

<p>相对地址，和我们前面算的都是一样的，除了我们自己的死循环，再也没有0xEAFFFFFE了。</p>

<p>文章最后的一个亮点，或许大家都发现了，挺关心那个<code>b 0x30000000</code>会有什么后果。令人吃惊的是，我全程编译都没有报错。连接器给出的结果很巧妙，解释了为什么错误的指令也不会产生错误。它在跳转0x30000000这个大跳时，发现距离太远，24位盛不下这么大的偏移量，于是先用了一个小跳，跳到一段连接器自动加入的代码，这段代码用ldr指令读取内存里存储的0x30000000存入PC，通过修改PC实现大跳。</p>

<p></p>

<p></p>

<p>、</p>

</body>
</html>

